<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>js07_객체_함수의사용</title>
<script type="text/javascript">
	//선언적 함수: function 키워드를 사용하여 정의, 이름이 있다.
	//           다른 객체나 함수에서 호출이 가능 -> 재사용
	//          파라미터 선언: 변수명만 작성 -> func(a,b){} -> 호출할때 func(5,6) (O)
	//                                                           func() (O) 
	//           리턴값을 정의할 수 있다. : return 키워드 사용
	function func01(){
		console.log("선언적함수");
		let val=func01_2(5,10);//다른 함수에서 호출
		console.log("연산결과:",val);
	}
	function func01_2(a,b){//파라미터 선언
		console.log(a,":",b);
		return a+":"+b;
	}
	
	//익명함수: 객체 내부에서 사용되고 종료-> 이름이 없어서
	//        변수에 할당해서 사용하면 호출 가능-> 변수명();
	//        파라미터로 기능을 전달할때 사용할 수 있다.
	//        ES5(2009년) --> ES6(2015년)
	//        화살표 함수 :  function(){}
	//                     --> ()=>{} 코드 간소화
	
	let i=0;//전역변수
	let func02=function(){
		console.log("익명함수");
		
// 		window.setInterval();// 지연시간을 두고 기능을 반복
// 		setInterval(function(){
// 			console.log(i++);
// 		}, 1000);

		setInterval(()=>{  // 화살표함수
			console.log(i++);
		}, 1000);
// 		setInterval(test, 1000);// 선언적함수로 기능전달할때
	}
	
	function test(){
		console.log(i++);
	}
	
	//onload이벤트는 페이지가 로딩되면 스크립트를 실행한다.
	onload=function(){
		var pArray=document.getElementsByClassName("a");// [p,p,p,p]
		console.log(pArray.length);
		// <p onclick="test()"/>
		//--- 객체 리터럴 방식으로 작성
		pArray[0].onclick=()=>{
			console.log("객체리터럴방식");
			//리터럴: 값 자체를 의미 --> var a=5;  var b=a;
			var jsonObj={
					"subject":"javascript",
					"credit":1,
					"printout":()=>jsonObj.subject+","+jsonObj.credit+"학점"
					//화살표함수의 코드가 리턴코드만 있다면 {} 생략가능
// 					"printout":function(){
// 									return jsonObj.subject+","+jsonObj.credit+"학점";
// 								}
			}
			
			//객체에 정의된 메서드를 사용
			console.log(jsonObj.printout());
			
			//객체의 값 변경하는 경우
			jsonObj.subject="JS"; // update개념
			jsonObj["test"]="value"; // insert개념
			delete jsonObj["credit"]; // delete 개념
			
			console.log(jsonObj.subject,jsonObj.credit,jsonObj.test);
			
			//ES6에서 추가된 기능
			//1.화살표 함수
			jsonObj["arrowFunc"]=(a,b)=>{console.log(a,b);};
			
			//2.구조분해할당 기능
			// -직접 구조 분해하고 할당하는 코드
			let subject1=jsonObj.subject;
			let test1=jsonObj.test;
			
			// -구조분해할당 문법사용
			let {subject,test} = jsonObj;//jsonObj에 선언된 이름과 같은 이름의 변수로 선언
			console.log("구조분해할당:",subject,test);
					
			// - 템플릿 리터럴
			// java에서 println("a"+5+":") -> printf("%d는 결과값이%d",5,10)
			console.log(`템플릿 리터럴:${subject},${test}`);
			
		}//pArray[0].onclick : 객체 리터럴 방식 종료 
		
		//2.객체 생성자 함수 방식-------------------------------------------
		pArray[1].onclick=()=>{
			// new 예약어 사용해서 객체 생성
			const info=new Info("javascript");
			console.log(`${info.subject},${info.credit},${info.printout()}`);
			console.log(info.getTest());
		}
		
		//생성자 함수
		function Info(subject){
			let test="일반 변수선언"; // 외부에서 접근 X
			
			//변수(메서드) 선언할때 this예약어를 사용
			this.subject=subject;
			this.credit=2;
			this.printout=function(){ //생성자함수 내부에 익명함수 정의할때 화살표함수(X)
					 		 return `${subject},${this.credit}학점`;
						  };
			
			//외부에서 메서드를 통해 속성에 접근 가능
			this.getTest=function(){
				return test;
			};
		}// 객체 생성자 함수 종료
		
		//3. 프로토타입 사용하기 
		// Info 객체에 추가적인 기능을 구현하고 싶을때(확장성)
		// 객체 간 기능을 공유해서 사용하고 싶을때 (메모리 효율, 재사용성)
		// 포로토타입을 안쓰는 경우: 객체 각각 따로 관리해야 하는 경우
		pArray[2].onclick=()=>{
			
			const infoA=new Info("javascript");//기존에 사용하던 객체에도 적용
			
			Info.prototype.addFunc=function(){
				console.log(`기능추가:${this.subject}`);//this사용해서 접근
			}
			
			const infoB=new Info("reactJS");// 앞으로 사용될 객체에도 적용
			
			infoA.addFunc();//기존에 사용되던 객체도 실행
			infoB.addFunc();//새로 사용되는 객체도 실행
			// 기본 속성과 기능을 가지고 있는 객체를 만들었는데
			// 이후에 모든 객체(기존 객체포함)들에게 공통적으로 사용할 기능을 추가하고 싶다면
			// 프로토타입으로 정의하면 된다.
			console.log(infoA.addFunc===infoB.addFunc);//같은 메서드를 공유하고 있다.
		}// 프로토타입 종료
		
		//클로저: 부모함수의 전달범위를 자식함수가 기억하는 상태
		pArray[3].onclick=()=>{
// 			closureTest1();
// 			closureTest2()();// closureTest2()--> 자식함수반환 --> 자식함수()
			
// 			closureTest2_2();//자식함수만 실행
			closureTest3();
		}
		
		let closureTest2_2=closureTest2();//자식함수를 반환하여 변수에 저장
		
		var count=0;//전역변수 선언: 상태 유지
		function closureTest1(){
// 			var count=0;//지역 변수: 함수 내부에서 사용-> 상태유지(X)
			count++;
			console.log(count);
		}
		
		//클로저 구현하는 방법
		function closureTest2(){
			var count=0;
			return function(){ // 익명함수를 리턴함
				count++;
				console.log(count);
			}
		}
		
		//클로저함수 완성
		let closureTest3=function(){
			var count=0;
			return function(){ // 익명함수를 리턴함
				count++;
				console.log(count);
			}
		}();// ()를 추가한 이유: 부모함수() 실행하기 위함--> 
								       //      자식함수 반환-> closureTeset3 할당
		
	}//onload 종료
	
</script>
</head>
<body>
	<h1>선언적 함수</h1>
	<p>
		이름이 정의되어 있는 기본적인 함수
		<button onclick="func01();">확인</button>
	</p>

	<h1>익명함수</h1>
	<p>
		이름이 없는 함수
		<button onclick="func02();">확인</button>
	</p>

	<h1>자바스크립트 객체 만들기</h1>
	<p class="a">1.객체 리터럴 방식</p>
	<p class="a">2.객체 생성자 함수 방식</p>
	<p class="a">3.프로토타입 사용하기</p>
	<p class="a">4.클로져 사용하기</p>
</body>
</html>